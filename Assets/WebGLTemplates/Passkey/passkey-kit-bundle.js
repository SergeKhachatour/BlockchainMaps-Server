(function(global) {
    'use strict';
    
    // Polyfill for require function to prevent "require is not defined" errors
    if (typeof require === 'undefined') {
        window.require = function() {
            console.warn('require() called but not implemented - this is expected for WebGL builds');
            return {};
        };
    }

    class PasskeyKit {
        constructor(config) {
            this.config = config;
            this.initialized = false;
            this.authenticated = false;
            this.walletAddress = null;
            this.publicKey = null;
        }

        async initialize() {
            if (this.initialized) return;
            
            // Initialize with provided config
            this.rpcUrl = this.config.rpcUrl || "https://soroban-testnet.stellar.org";
            this.networkPassphrase = this.config.networkPassphrase || "Test SDF Network ; September 2015";
            this.factoryContractId = this.config.factoryContractId;
            
            // Check if WebAuthn is supported
            if (!window.PublicKeyCredential) {
                throw new Error('WebAuthn is not supported in this browser');
            }
            
            this.initialized = true;
            console.log('PasskeyKit initialized successfully');
            return true;
        }

        async authenticate(username) {
            if (!this.initialized) await this.initialize();
            
            try {
                // Check if user has existing credentials
                const existingCredentials = await this.checkExistingCredentials(username);
                
                if (existingCredentials) {
                    // User has existing passkey - authenticate
                    console.log('Authenticating existing user:', username);
                    await this.authenticateWithPasskey(username);
                } else {
                    // New user - create passkey and wallet
                    console.log('Creating new user with passkey:', username);
                    await this.createPasskeyAndWallet(username);
                }
                
                this.authenticated = true;
                console.log('Authentication complete. Final wallet address:', this.walletAddress);
                return true;
            } catch (error) {
                console.error('Authentication failed:', error);
                this.authenticated = false;
                throw error;
            }
        }

        async checkExistingCredentials(username) {
            try {
                // Check if there are any existing credentials for this user
                const existingCredentials = await navigator.credentials.get({
                    publicKey: {
                        challenge: new Uint8Array(32),
                        rpId: window.location.hostname,
                        userVerification: 'preferred'
                    }
                });
                return existingCredentials !== null;
            } catch (error) {
                // No existing credentials found
                return false;
            }
        }

        async createPasskeyAndWallet(username) {
            // Don't generate a wallet - let the backend handle it
            this.publicKey = null;
            this.walletAddress = null;
            
            console.log('Passkey created - wallet will be generated by backend');
            
            // Create passkey credential
            const challenge = new Uint8Array(32);
            crypto.getRandomValues(challenge);
            
            const publicKeyCredentialCreationOptions = {
                challenge: challenge,
                rp: {
                    name: "BlockchainMaps",
                    id: window.location.hostname
                },
                user: {
                    id: new Uint8Array(16),
                    name: username,
                    displayName: username
                },
                pubKeyCredParams: [{
                    type: "public-key",
                    alg: -7 // ES256
                }],
                authenticatorSelection: {
                    authenticatorAttachment: "platform",
                    userVerification: "preferred"
                },
                timeout: 60000
            };
            
            try {
                const credential = await navigator.credentials.create({
                    publicKey: publicKeyCredentialCreationOptions
                });
                
                console.log('Passkey created successfully for user:', username);
                console.log('Final wallet address:', this.walletAddress);
                
                // Store the credential ID for future authentication
                localStorage.setItem(`passkey_${username}`, credential.id);
                localStorage.setItem(`wallet_${username}`, this.walletAddress);
                
                // Ensure wallet address is set
                this.authenticated = true;
                
                return credential;
            } catch (error) {
                console.error('Failed to create passkey:', error);
                throw new Error('Failed to create passkey: ' + error.message);
            }
        }

        async authenticateWithPasskey(username) {
            // Don't generate or retrieve wallet - let the backend handle it
            this.walletAddress = null;
            this.publicKey = null;
            console.log('Passkey authentication - wallet will be generated by backend');
            
            const challenge = new Uint8Array(32);
            crypto.getRandomValues(challenge);
            
            const assertionOptions = {
                challenge: challenge,
                rpId: window.location.hostname,
                userVerification: 'preferred',
                timeout: 60000
            };
            
            try {
                const assertion = await navigator.credentials.get({
                    publicKey: assertionOptions
                });
                
                console.log('Authentication successful for user:', username);
                console.log('Final wallet address:', this.walletAddress);
                
                return assertion;
            } catch (error) {
                console.error('Authentication failed:', error);
                throw new Error('Authentication failed: ' + error.message);
            }
        }

        async generateStellarKeypair() {
            // Check if Stellar SDK is available
            if (typeof StellarSdk === 'undefined') {
                throw new Error('Stellar SDK not available. Cannot generate real Stellar addresses without the SDK.');
            }

            // Use Stellar SDK to generate a proper keypair
            const keypair = StellarSdk.Keypair.random();
            const publicKey = keypair.publicKey();
            const secretKey = keypair.secret();

            console.log('Generated real Stellar keypair:', publicKey);
            
            return {
                publicKey: () => publicKey,
                secret: () => secretKey
            };
        }

        async signTransaction(txData) {
            if (!this.authenticated) {
                throw new Error('User must be authenticated before signing transactions');
            }
            
            if (!this.initialized) await this.initialize();
            
            try {
                // In a real implementation, this would use the Stellar SDK to sign the transaction
                console.log('Signing transaction:', txData);
                console.log('Using wallet address:', this.walletAddress);
                
                // For now, return a simulated signature
                return {
                    signature: 'simulated_signature_' + Date.now(),
                    publicKey: this.walletAddress,
                    walletAddress: this.walletAddress
                };
            } catch (error) {
                console.error('Transaction signing failed:', error);
                throw error;
            }
        }

        getWalletAddress() {
            console.log('getWalletAddress called, current walletAddress:', this.walletAddress);
            return this.walletAddress;
        }

        isAuthenticated() {
            return this.authenticated;
        }

        logOff() {
            this.authenticated = false;
            this.walletAddress = null;
            this.publicKey = null;
            console.log('User logged off');
        }

        // Freighter wallet integration
        async connectFreighterWallet() {
            try {
                if (typeof window.freighterApi !== 'undefined') {
                    console.log('Freighter wallet detected, attempting to connect...');
                    
                    // Check if Freighter is installed
                    const isConnected = await window.freighterApi.isConnected();
                    if (!isConnected) {
                        await window.freighterApi.connect();
                    }
                    
                    // Get the connected account
                    const publicKey = await window.freighterApi.getPublicKey();
                    if (publicKey) {
                        this.walletAddress = publicKey;
                        this.publicKey = publicKey;
                        this.authenticated = true;
                        console.log('Connected to Freighter wallet:', publicKey);
                        return publicKey;
                    }
                } else {
                    console.log('Freighter wallet not detected');
                    return null;
                }
            } catch (error) {
                console.error('Error connecting to Freighter wallet:', error);
                return null;
            }
        }

        // Check if Freighter is available
        isFreighterAvailable() {
            return typeof window.freighterApi !== 'undefined';
        }

        // Test method to generate a wallet address
        async testGenerateWallet() {
            console.log('Testing wallet generation...');
            const keypair = await this.generateStellarKeypair();
            const testAddress = keypair.publicKey();
            console.log('Test wallet address generated:', testAddress);
            return testAddress;
        }
    }

    // Export to global scope
    global.PasskeyKit = PasskeyKit;
})(typeof window !== 'undefined' ? window : this); 